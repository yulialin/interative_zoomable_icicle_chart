# -*- coding: utf-8 -*-
"""Interactive Icicle Chart POC

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16YcjFVGhp-oMOVtZ8QjoByGB7RqzZmen
"""

!pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib plotly

import json
from IPython.display import display, HTML, IFrame
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from google.colab import files
import plotly.io as pio
pio.renderers.default = "colab"


uploaded = files.upload()

# Read and parse the JSONL file
uploaded_file_path = '/content/DependTable (1).jsonl'
raw_data = []
with open(uploaded_file_path, 'r') as file:
    for line in file:
        raw_data.append(json.loads(line))

# Convert raw_data to JSON
columns = list(raw_data[0].keys()) if raw_data else []
data = [[item[col] for col in columns] for item in raw_data]
rawData_js = json.dumps([columns] + data)

html_with_js = f"""
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Icicle Chart</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body {{
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }}
    h1 {{
      text-align: center;
      margin-top: 20px;
    }}
    /* Header container styled as a flex row */
    #headers {{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 10px auto;
      width: 960px;
      border-bottom: 2px solid #ccc;
    }}
    #headers > div {{
      flex: 1;
      text-align: center;
      font-weight: bold;
      font-size: 16px;
      color: #000;
      border: 1px solid #ccc;
      padding: 5px 0;
      background-color: #f0f0f0;
      box-sizing: border-box;
      margin: 0 2px;
    }}
    .flag {{
      color: red;
      font-weight: bold;
    }}
    .tooltip {{
      font-size: 12px;
      color: black;
      background-color: white;
      border: 1px solid black;
      padding: 5px;
      border-radius: 5px;
      display: none;
      pointer-events: none;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }}
    .modal {{
      width: 400px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
    }}
  </style>
</head>
<body>
  <h1>Interactive Icicle Chart</h1>
  <div id="headers"></div>
  <div id="chart"></div>

  <script>
    const rawData = {rawData_js};
    const columnNames = rawData[0];
    const rows = rawData.slice(1);

    const hierarchicalData = convertToHierarchy(rows, columnNames);
    renderChart(hierarchicalData, columnNames);

    function convertToHierarchy(data, columnNames) {{
      const hierarchy = {{ name: "Acme Corporation", children: [] }};
      data.forEach(row => {{
        let currentLevel = hierarchy;
        columnNames.forEach((column, index) => {{
          if (column === "ID" || column.endsWith("Flag")) return;
          const value = row[index];
          const flag = row[index + 1];
          if (value) {{
            let child = currentLevel.children.find(c => c.name === value);
            if (!child) {{
              child = {{
                name: value,
                flagged: flag === "FLAG",
                id: row[columnNames.indexOf("ID")],
                children: []
              }};
              currentLevel.children.push(child);
            }}
            currentLevel = child;
          }}
        }});
      }});
      return hierarchy;
    }}

    function renderChart(data, columnNames) {{
      const width = 960;
      const height = 500;

      // Clear previous content
      d3.select("#chart").html("");
      d3.select("#headers").html("");

      const tooltip = d3.select("body").append("div")
          .attr("class", "tooltip")
          .style("position", "absolute")
          .style("background-color", "white")
          .style("border", "1px solid black")
          .style("padding", "5px")
          .style("border-radius", "5px")
          .style("display", "none")
          .style("pointer-events", "none");

      const modal = d3.select("body").append("div")
          .attr("class", "modal")
          .style("position", "fixed")
          .style("top", "50%")
          .style("left", "50%")
          .style("transform", "translate(-50%, -50%)")
          .style("background-color", "white")
          .style("border", "1px solid black")
          .style("padding", "20px")
          .style("border-radius", "5px")
          .style("display", "none")
          .style("z-index", "1000");

      const closeModal = () => modal.style("display", "none");
      modal.append("button")
          .text("Close")
          .style("margin-bottom", "10px")
          .on("click", closeModal);

      const contentDiv = modal.append("div");

      const svg = d3.select("#chart")
          .append("svg")
          .attr("viewBox", [0, 0, width, height])
          .attr("width", width)
          .attr("height", height)
          .style("font", "10px sans-serif");

      const partition = d3.partition().size([height, width]);

      const root = d3.hierarchy(data)
          .sum(d => d.children && d.children.length > 0 ? 0 : 1)
          .sort((a, b) => b.height - a.height || b.value - a.value);

      partition(root);

      // **Assign initial target coordinates equal to original coordinates**
      root.each(d => {{
          d.target = {{
              x0: d.x0,
              x1: d.x1,
              y0: d.y0,
              y1: d.y1
          }};
      }});

      // Update headers (the flex container above the SVG)
      updateHeaders(root, columnNames);

      const chartGroup = svg.append("g");

      // Use d.target for initial positioning to avoid overlaps
      const cell = chartGroup.selectAll("g")
          .data(root.descendants())
          .join("g")
          .attr("transform", d => `translate(${{d.target.y0}},${{d.target.x0}})`);

      const baseColor = "#264d73";
      const colorScale = generateColorScale(baseColor, root.height);

      const rect = cell.append("rect")
          .attr("width", d => d.target.y1 - d.target.y0 - 1)
          .attr("height", d => rectHeight(d.target))
          .attr("fill-opacity", 0.6)
          .attr("fill", d => d.data.flagged ? "red" : colorScale(d.depth))
          .style("stroke", "white")
          .style("stroke-width", d => (d.depth === 1 ? "1px" : "0.5px"))
          .on("mouseover", (event, d) => {{
              tooltip.style("display", "block")
                  .html(`
                    <strong>${{d.data.name}}</strong><br>
                    Value: ${{d.value}}<br>
                    ${{d.data.flagged ? "⚠️ Flagged!" : ""}}
                  `)
                  .style("left", `${{event.pageX + 10}}px`)
                  .style("top", `${{event.pageY}}px`);
          }})
          .on("mousemove", event => {{
              tooltip.style("left", `${{event.pageX + 10}}px`)
                     .style("top", `${{event.pageY}}px`);
          }})
          .on("mouseout", () => tooltip.style("display", "none"))
          .on("click", clicked);

      // Allow pointer events so that the [Details] tspan is clickable.
      const text = cell.append("text")
          .style("user-select", "none")
          .attr("x", 4)
          .attr("y", 13)
          .attr("fill-opacity", d => +labelVisible(d.target))
          .style("fill", "white")
          .text(d => `${{d.data.name}} (${{d.value}})`);

      // If a cell is flagged, add an extra tspan.
      text.filter(d => d.data.flagged)
          .append("tspan")
          .attr("x", 4)
          .attr("dy", "1.2em")
          .style("fill", "yellow")
          .text(" ⚠️ Flag!");

      // Append a clickable [Details] link (for cells at depth 1)
      text.filter(d => d.depth === 1)
          .append("tspan")
          .attr("class", "details-link")
          .attr("x", 4)
          .attr("dy", "1.2em")
          .style("fill", "blue")
          .style("cursor", "pointer")
          .style("pointer-events", "all")
          .text(" [Details]")
          .on("click", (event, d) => {{
              event.stopPropagation(); // Prevent the cell zoom from firing.
              modal.style("display", "block");
              contentDiv.html(`
                <h2>${{d.data.name}}</h2>
                <p>Value: ${{d.value}}</p>
                ${{d.data.flagged ? "<p style='color: red;'>⚠️ This is flagged!</p>" : ""}}
                <p>
                  <a href="https://example.com/link1" target="_blank">Link 1</a> |
                  <a href="https://example.com/link2" target="_blank">Link 2</a>
                </p>
              `);
          }});

      cell.append("title")
          .text(d => `${{d.ancestors().map(d => d.data.name).reverse().join("/")}}`);

      let focus = root;

      function clicked(event, p) {{
          if (focus === p) {{
              p = p.parent;
          }}
          if (!p) return;
          focus = p;

          root.each(d => d.target = {{
              x0: (d.x0 - p.x0) / (p.x1 - p.x0) * height,
              x1: (d.x1 - p.x0) / (p.x1 - p.x0) * height,
              y0: d.y0 - p.y0,
              y1: d.y1 - p.y0
          }});

          const t = cell.transition().duration(750)
              .attr("transform", d => `translate(${{d.target.y0}},${{d.target.x0}})`);

          rect.transition(t).attr("height", d => rectHeight(d.target));
          text.transition(t).attr("fill-opacity", d => +labelVisible(d.target));
          updateHeaders(p, columnNames);
      }}

      // Increase cell height if the cell contains the [Details] link (depth 1)
      function rectHeight(d) {{
          let baseHeight = d.x1 - d.x0 - Math.min(1, (d.x1 - d.x0) / 2);
          return d.depth === 1 ? baseHeight + 20 : baseHeight;
      }}

      function labelVisible(d) {{
          return d.y1 <= width && d.y0 >= 0 && d.x1 - d.x0 > 16;
      }}

      function generateColorScale(baseColor, maxDepth) {{
          const lightColor = d3.rgb(baseColor).brighter(2).toString();
          const darkColor = d3.rgb(baseColor).darker(2).toString();
          return d3.scaleLinear()
              .domain([0, maxDepth])
              .range([lightColor, darkColor]);
      }}

      // Revised updateHeaders function:
      // - At the default (root) level (focus.depth === 0) prepend "All"
      // - Otherwise, omit "All"
      function updateHeaders(focus, columnNames) {{
          const headersDiv = d3.select("#headers");
          headersDiv.html("");
          const filteredColumns = columnNames.filter(col => col !== "ID" && !col.endsWith("Flag"));
          let headers = focus.depth === 0 ? ["All"].concat(filteredColumns) : filteredColumns.slice(focus.depth - 1);
          headers.forEach(header => {{
              headersDiv.append("div").text(header);
          }});
      }}
    }}
  </script>
</body>
</html>
"""

print(raw_data)

display(HTML(html_with_js))

print(html_with_js)

with open('/content/interactive_icicle_chart.html', 'w') as f:
    f.write(html_with_js)
files.download('/content/interactive_icicle_chart.html')